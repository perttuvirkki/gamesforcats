default_platform(:ios)

def resolve_existing_path(path, fastlane_dir, project_dir)
  return nil if path.to_s.strip.empty?
  candidates = [
    path,
    File.expand_path(path, fastlane_dir),
    File.expand_path(path, project_dir)
  ]
  candidates.find { |candidate| File.exist?(candidate) }
end

platform :android do
  desc "Upload Google Play listing metadata from fastlane/metadata-android"
  lane :metadata do
    fastlane_dir = File.expand_path(__dir__)
    project_dir = File.expand_path("..", fastlane_dir)

    require_relative "scripts/sync_play_store_metadata"
    require_relative "scripts/sync_play_store_screenshots"
    dry_run = ENV["DRY_RUN"].to_s.strip != "0"
    SyncPlayStoreMetadata.run!(
      source_dir: File.join(fastlane_dir, "metadata"),
      target_dir: File.join(fastlane_dir, "metadata-android"),
      dry_run: dry_run
    )

    screenshots_source = File.join(project_dir, "assets", "android")
    if File.directory?(screenshots_source)
      duplicate_uk_from_us = ENV["DUPLICATE_UK_FROM_US"].to_s.strip != "0"
      duplicate_seven_from_ten = ENV["DUPLICATE_SEVEN_FROM_TEN"].to_s.strip != "0"
      SyncPlayStoreScreenshots.run!(
        source_dir: screenshots_source,
        target_dir: File.join(fastlane_dir, "metadata-android"),
        dry_run: dry_run,
        duplicate_uk_from_us: duplicate_uk_from_us,
        duplicate_seven_from_ten: duplicate_seven_from_ten
      )
    end

    if dry_run
      UI.important("DRY_RUN enabled: skipping supply upload")
      next
    end

    json_key_path = resolve_existing_path(ENV["SUPPLY_JSON_KEY"], fastlane_dir, project_dir)
    UI.user_error!("Missing SUPPLY_JSON_KEY (path to Google Play service account JSON)") if json_key_path.to_s.strip.empty?

    upload_images = ENV["UPLOAD_IMAGES"].to_s.strip == "1"
    upload_screenshots = ENV["UPLOAD_SCREENSHOTS"].to_s.strip == "1"
    upload_changelogs = ENV["UPLOAD_CHANGELOGS"].to_s.strip == "1"

    track = ENV["SUPPLY_TRACK"].to_s.strip
    track = "internal" if track.empty?
    version_code_env = ENV["SUPPLY_VERSION_CODE"].to_s.strip
    version_code = version_code_env.empty? ? nil : version_code_env
    release_status_env = ENV["SUPPLY_RELEASE_STATUS"].to_s.strip
    changes_not_sent_env = ENV["SUPPLY_CHANGES_NOT_SENT_FOR_REVIEW"]
    changes_not_sent =
      if changes_not_sent_env.nil?
        true
      else
        %w[1 true yes y].include?(changes_not_sent_env.to_s.strip.downcase)
      end

    supply_args = {
      package_name: "com.ludussuper.gamesforcats",
      json_key: json_key_path,
      metadata_path: File.join(fastlane_dir, "metadata-android"),
      track: track,
      version_code: version_code,
      changes_not_sent_for_review: changes_not_sent,
      skip_upload_metadata: false,
      skip_upload_apk: true,
      skip_upload_aab: true,
      skip_upload_images: !upload_images,
      skip_upload_screenshots: !upload_screenshots,
      skip_upload_changelogs: !upload_changelogs
    }
    supply_args[:release_status] = release_status_env unless release_status_env.empty?
    # Play Console draft apps can require creating/updating a draft release on a track.
    # When user targets a specific version code and requests a draft release, attach that version code to the track release.
    if !release_status_env.empty? && release_status_env == "draft" && !version_code_env.empty?
      begin
        supply_args[:version_codes_to_retain] = [Integer(version_code_env)]
      rescue
        # ignore invalid version code
      end
    end

    supply(**supply_args)
  end
end

platform :ios do
  desc "Upload App Store metadata from fastlane/metadata (optional screenshots)"
  lane :metadata do
    fastlane_dir = File.expand_path(__dir__)
    project_dir = File.expand_path("..", fastlane_dir)
    require "fileutils"

    key_path = resolve_existing_path(ENV["ASC_KEY_PATH"], fastlane_dir, project_dir)
    key_path ||= Dir[File.join(fastlane_dir, "AuthKey_*.p8")].first
    UI.user_error!("Missing ASC_KEY_PATH and no AuthKey_*.p8 found in fastlane/") if key_path.to_s.strip.empty?

    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_filepath: key_path,
      duration: 1200
    )

    upload_screenshots = ENV["UPLOAD_SCREENSHOTS"].to_s.strip == "1"
    overwrite_screenshots = ENV["OVERWRITE_SCREENSHOTS"].to_s.strip == "1"
    duplicate_uk_from_us = ENV["DUPLICATE_UK_FROM_US"].to_s.strip != "0"

    screenshots_source_paths_env = ENV["SCREENSHOTS_PATH"].to_s
    screenshots_source_paths =
      if screenshots_source_paths_env.strip.length > 0
        screenshots_source_paths_env
          .split(",")
          .map(&:strip)
          .map { |p| resolve_existing_path(p, fastlane_dir, project_dir) }
          .compact
      else
        candidates = []
        candidates << File.join(fastlane_dir, "apple") if File.directory?(File.join(fastlane_dir, "apple"))
        candidates << File.join(fastlane_dir, "appleipad") if File.directory?(File.join(fastlane_dir, "appleipad"))
        candidates << File.join(fastlane_dir, "screenshots") if candidates.empty?
        candidates
      end

    normalized_screenshots_path = File.join(fastlane_dir, ".deliver_screenshots")
    screenshots_path = screenshots_source_paths.first

    if upload_screenshots
      UI.user_error!("UPLOAD_SCREENSHOTS=1 set, but no screenshot source folders found") if screenshots_source_paths.empty?

      apple_style_source = lambda do |path|
        File.directory?(path) &&
          Dir.children(path).any? do |entry|
            next false unless File.directory?(File.join(path, entry))
            entry.match?(/\([^)]+\)\s*\z/)
          end
      end

      needs_normalization = screenshots_source_paths.length > 1 || screenshots_source_paths.any? { |p| apple_style_source.call(p) }

      if needs_normalization
        FileUtils.rm_rf(normalized_screenshots_path)
        FileUtils.mkdir_p(normalized_screenshots_path)

        device_prefix = lambda do |input|
          input
            .to_s
            .strip
            .gsub(/\s+/, "_")
            .gsub(/[^A-Za-z0-9._-]/, "")
            .downcase
        end

        normalize_apple_source = lambda do |source_path|
          Dir.children(source_path).sort.each do |locale_dir|
            locale_path = File.join(source_path, locale_dir)
            next unless File.directory?(locale_path)

            locale_code = locale_dir[/\(([^)]+)\)\s*\z/, 1] || locale_dir.strip
            next if locale_code.to_s.strip.empty?

            target_dir = File.join(normalized_screenshots_path, locale_code)
            FileUtils.mkdir_p(target_dir)

            Dir.children(locale_path).sort.each do |device_dir|
              device_path = File.join(locale_path, device_dir)
              next unless File.directory?(device_path)

              prefix = device_prefix.call(device_dir)
              prefix = "device" if prefix.to_s.strip.empty?

              Dir.glob(File.join(device_path, "*.{png,jpg,jpeg}"), File::FNM_CASEFOLD).sort.each do |image|
                dest = File.join(target_dir, "#{prefix}_#{File.basename(image)}")
                FileUtils.cp(image, dest)
              end
            end
          end
        end

        screenshots_source_paths.each do |source_path|
          if apple_style_source.call(source_path)
            normalize_apple_source.call(source_path)
          else
            UI.user_error!("Unsupported screenshot source format at #{source_path} (expected Apple-style locales like 'English (en-US)')") unless File.directory?(source_path)
            Dir.glob(File.join(source_path, "*")).each do |entry|
              next if File.basename(entry).start_with?(".")
              FileUtils.cp_r(entry, File.join(normalized_screenshots_path, File.basename(entry)))
            end
          end
        end

        if duplicate_uk_from_us
          us_dir = File.join(normalized_screenshots_path, "en-US")
          uk_dir = File.join(normalized_screenshots_path, "en-GB")
          if File.directory?(us_dir) && !File.directory?(uk_dir)
            FileUtils.mkdir_p(uk_dir)
            Dir.glob(File.join(us_dir, "*")).sort.each do |img|
              next unless File.file?(img)
              FileUtils.cp(img, File.join(uk_dir, File.basename(img)))
            end
          end
        end

        screenshots_path = normalized_screenshots_path
      end

      screenshots = Dir.glob(File.join(screenshots_path, "**", "*.{png,jpg,jpeg}"), File::FNM_CASEFOLD).select { |p| File.file?(p) }
      UI.user_error!("UPLOAD_SCREENSHOTS=1 set, but no screenshots found in #{screenshots_path}") if screenshots.empty?
    end

    deliver(
      api_key: api_key,
      app_identifier: "com.ludussuper.gamesforcats",
      metadata_path: File.join(fastlane_dir, "metadata"),
      screenshots_path: screenshots_path,
      skip_screenshots: !upload_screenshots,
      overwrite_screenshots: overwrite_screenshots,
      skip_binary_upload: true,
      run_precheck_before_submit: false,
      force: true
    )
  end

  desc "Sync App Store Connect subscription localizations from fastlane/subscriptions"
  lane :subscription_localizations do
    fastlane_dir = File.expand_path(__dir__)
    project_dir = File.expand_path("..", fastlane_dir)

    key_path = resolve_existing_path(ENV["ASC_KEY_PATH"], fastlane_dir, project_dir)
    key_path ||= Dir[File.join(fastlane_dir, "AuthKey_*.p8")].first
    UI.user_error!("Missing ASC_KEY_PATH and no AuthKey_*.p8 found in fastlane/") if key_path.to_s.strip.empty?

    require_relative "scripts/sync_subscription_localizations"

    SyncSubscriptionLocalizations.run!(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_path: key_path,
      bundle_id: CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier),
      source_dir: File.join(fastlane_dir, "subscriptions"),
      dry_run: ENV["DRY_RUN"].to_s.strip != "0"
    )
  end
end
